import pandas as pd
import numpy as np
import math
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import RandomizedSearchCV


def get_tables_for_year(year):
    df = pd.read_csv("Investment_Data_Train (1).csv")
    new_df = df[['MSN', 'StateCode', 'Year', 'Amount',
                 'CO2 Emissions (Mmt)', 'TotalNumberofInvestments',
                 'TotalAmountofAssistance']]

    states_df = new_df[~new_df['StateCode'].isin(['DC', 'US', 'X3', 'X5'])]
    states_df2 = states_df[states_df['Year'] == year]

    MSN_df = states_df2.pivot(index="StateCode", columns=("MSN"), values="Amount")
    MSN_df.drop(['WDEXB', 'BDPRP', 'BFPRP', 'CLPRP', 'COPRK', 'ENPRP', 'NGMPK', 'NGMPP', 'PAPRP'], axis=1, inplace=True)
    Metrics_df = states_df2[['StateCode', 'CO2 Emissions (Mmt)', 'TotalNumberofInvestments', 'TotalAmountofAssistance']]
    Metrics_df = Metrics_df.drop_duplicates(subset=None, keep="first", inplace=False)
    Metrics_df.set_index('StateCode', inplace=True)

    return MSN_df, Metrics_df.TotalAmountofAssistance

MSN_frames = []
metrics_frames = []

for year in range(2015, 2019):
    MSN_frames.append(get_tables_for_year(year)[0])
    metrics_frames.append(get_tables_for_year(year)[1])

#creates MSN matrix for years from 2015-2018
all_MSN = pd.concat(MSN_frames)
all_metrics = pd.concat(metrics_frames)

msn2019, metrics2019 = get_tables_for_year(2019)

grid = {"n_estimators": [10, 50, 100, 200, 500, 1000],
        "max_depth": [None, 5, 10, 20, 30],
        "max_features": ["auto","sqrt"],
        "min_samples_split": [2,4,6],
        "min_samples_leaf": [1,2,4]}

np.random.seed(42)

X_train = all_MSN
y_train = all_metrics

X_test = msn2019
y_test = metrics2019

rfr = RandomForestRegressor(n_jobs=1)

rs_rfr = RandomizedSearchCV(estimator=rfr,
                            param_distributions=grid,
                            n_iter=50,
                            cv = 5,
                            verbose=2)
rs_rfr.fit(X_train,y_train)



def prediction_error(predictions, actual_result):
    """
    Calculate the MSE between the actual measured
    data and the predictions generated by this model
    based on the input data.

    inputs:
        - inputs: inputs: an n x m matrix of explanatory variables
        - actual_result: an n x 1 matrix of the corresponding
                         actual values for the measured variables

    Returns: a float that is the MSE between the generated
    data and the actual data
    """

    # generate the predictions
    prediction_matrix = predictions
    vals = np.shape(prediction_matrix)
    rows = vals[0]

    # initialize the mse
    mse_total = 0

    # add the squared error for each data to the mse
    for curr_row in range(rows):
        pred_val = prediction_matrix[curr_row]
        actual_val = actual_result[curr_row]
        error = actual_val - pred_val
        squared_error = error ** 2
        mse_total += squared_error

    # compute the mse
    mse = mse_total / rows

    return mse


preds = rs_rfr.predict(X_test)
vals = prediction_error(preds,y_test)
print(vals)
